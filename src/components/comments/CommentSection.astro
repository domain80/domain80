---
import AuthButton from "../auth/AuthButton.astro";

interface Props {
  slug: string;
}

const { slug } = Astro.props;
---

<section
  class="comment-section mt-16 pt-8 border-t border-zinc-200 dark:border-zinc-800"
  data-slug={slug}
>
  <!-- Comments Header -->
  <div class="flex items-center justify-between mb-6">
    <div class="flex items-center gap-2">
      <h2 class="text-base font-semibold text-zinc-900 dark:text-zinc-100">
        Comments
      </h2>
      <span
        id="comment-count"
        class="bg-accent text-white text-xs px-2 py-0.5 rounded-full">0</span
      >
    </div>
    <div class="flex items-center gap-3">
      <!-- Thread Lines Toggle -->
      <button
        id="toggle-lines-btn"
        class="p-1.5 text-zinc-500 hover:text-zinc-700 dark:text-zinc-400 dark:hover:text-zinc-200 rounded hover:bg-zinc-100 dark:hover:bg-zinc-800"
        title="Toggle thread lines"
      >
        <svg
          class="w-4 h-4"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          ><path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M4 6h16M4 12h8m-8 6h16"></path></svg
        >
      </button>
      <!-- Sort Dropdown -->
      <div class="relative">
        <button
          id="sort-btn"
          class="flex items-center gap-1.5 text-sm text-zinc-600 dark:text-zinc-400 hover:text-zinc-900 dark:hover:text-zinc-200"
        >
          <svg
            class="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            ><path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"></path></svg
          >
          <span id="sort-label">Most recent</span>
          <svg
            class="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            ><path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M19 9l-7 7-7-7"></path></svg
          >
        </button>
        <div
          id="sort-dropdown"
          class="hidden absolute right-0 mt-1 bg-white dark:bg-zinc-800 rounded-lg shadow-lg border border-zinc-200 dark:border-zinc-700 py-1 min-w-[140px] z-10"
        >
          <button
            data-sort="recent"
            class="w-full px-3 py-1.5 text-left text-sm text-zinc-700 dark:text-zinc-300 hover:bg-zinc-100 dark:hover:bg-zinc-700"
            >Most recent</button
          >
          <button
            data-sort="oldest"
            class="w-full px-3 py-1.5 text-left text-sm text-zinc-700 dark:text-zinc-300 hover:bg-zinc-100 dark:hover:bg-zinc-700"
            >Oldest</button
          >
          <button
            data-sort="popular"
            class="w-full px-3 py-1.5 text-left text-sm text-zinc-700 dark:text-zinc-300 hover:bg-zinc-100 dark:hover:bg-zinc-700"
            >Most liked</button
          >
        </div>
      </div>
    </div>
  </div>

  <!-- Auth -->
  <div class="mb-8">
    <AuthButton />
  </div>

  <!-- Comment Form (shown when logged in) -->
  <div id="comment-form-container" class="hidden mb-8">
    <form id="comment-form" class="bg-zinc-100/80 dark:bg-zinc-800 rounded-lg p-4 border border-zinc-300 dark:border-zinc-700">
      <textarea
        id="comment-input"
        name="content"
        placeholder="Add comment..."
        rows="3"
        class="w-full bg-transparent border-none outline-none resize-none text-sm text-zinc-700 dark:text-zinc-200 placeholder-zinc-400"
      ></textarea>
      <div
        class="flex items-center justify-between mt-3 pt-3 border-t border-zinc-200 dark:border-zinc-700"
      >
        <div class="flex items-center gap-1">
          <button
            type="button"
            data-format="bold"
            class="p-1.5 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded text-zinc-700 dark:text-zinc-300 font-bold text-sm"
            title="Bold">B</button
          >
          <button
            type="button"
            data-format="italic"
            class="p-1.5 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded text-zinc-700 dark:text-zinc-300 italic text-sm"
            title="Italic">I</button
          >
          <button
            type="button"
            data-format="underline"
            class="p-1.5 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded text-zinc-700 dark:text-zinc-300 underline text-sm"
            title="Underline">U</button
          >
          <span class="w-px h-4 bg-zinc-300 dark:bg-zinc-600 mx-2"></span>
          <button
            type="button"
            data-action="emoji"
            class="p-1.5 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded text-zinc-700 dark:text-zinc-300"
            title="Emoji"
          >
            <svg
              class="w-4 h-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              ><path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              ></path></svg
            >
          </button>
        </div>
        <button
          type="submit"
          class="px-5 py-1.5 bg-accent text-white rounded-lg hover:opacity-90 transition-opacity text-sm font-medium"
        >
          Submit
        </button>
      </div>
    </form>
    <!-- Emoji Picker Popup -->
    <div
      id="emoji-picker"
      class="hidden absolute mt-2 bg-white dark:bg-zinc-800 rounded-lg shadow-lg border border-zinc-200 dark:border-zinc-700 p-3 z-20"
    >
      <div class="grid grid-cols-8 gap-1 text-xl">
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üòÄ</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üòÇ</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üòç</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >ü§î</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üëç</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üëé</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >‚ù§Ô∏è</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üî•</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üéâ</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üíØ</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üôè</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üò¢</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üòÆ</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üòé</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >ü§£</button
        >
        <button
          type="button"
          class="emoji-btn p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded"
          >üëè</button
        >
      </div>
    </div>
  </div>

  <!-- Login prompt (shown when logged out) -->
  <div
    id="login-prompt"
    class="hidden mb-8 p-4 bg-zinc-100 dark:bg-zinc-800 rounded-lg text-center"
  >
    <p class="text-zinc-600 dark:text-zinc-400">Sign in to leave a comment</p>
  </div>

  <!-- Comments List -->
  <ul id="comments-list" class="comment-thread" style="--lines: true;">
    <li class="text-zinc-500 text-sm list-none">Loading comments...</li>
  </ul>
</section>

<script>
  import {
    supabase,
    type Comment,
    type CommentReaction,
    type Profile,
  } from "../../lib/supabase";
  import {
    initAuth,
    getCachedComments,
    setCachedComments,
    invalidateComments,
  } from "../../lib/stores";

  interface CommentWithProfile extends Comment {
    profiles: Profile;
    replies?: CommentWithProfile[];
    comment_reactions?: CommentReaction[];
  }

  async function initCommentSection() {
    const section = document.querySelector(".comment-section");
    if (!section) return;

    const slug = section.getAttribute("data-slug");
    if (!slug) return;

    const formContainer = document.getElementById("comment-form-container");
    const loginPrompt = document.getElementById("login-prompt");
    const commentsList = document.getElementById("comments-list");
    const commentForm = document.getElementById("comment-form");
    const commentInput = document.getElementById(
      "comment-input"
    ) as HTMLTextAreaElement;
    const commentCount = document.getElementById("comment-count");
    const sortBtn = document.getElementById("sort-btn");
    const sortDropdown = document.getElementById("sort-dropdown");
    const sortLabel = document.getElementById("sort-label");
    const emojiBtn = document.querySelector('[data-action="emoji"]');
    const emojiPicker = document.getElementById("emoji-picker");
    const toggleLinesBtn = document.getElementById("toggle-lines-btn");

    let currentSort = "recent";

    // Thread lines toggle handler
    const savedLinesPref = localStorage.getItem("comment-thread-lines");
    if (savedLinesPref && commentsList) {
      commentsList.style.setProperty("--lines", savedLinesPref);
    }

    toggleLinesBtn?.addEventListener("click", () => {
      if (!commentsList) return;
      const currentLines = commentsList.style.getPropertyValue("--lines");
      const newValue = currentLines === "false" ? "true" : "false";
      commentsList.style.setProperty("--lines", newValue);
      localStorage.setItem("comment-thread-lines", newValue);
    });

    // Use shared auth store (cached)
    const authState = await initAuth();
    const session = authState.session;

    // Use profile from auth store
    const currentUserProfile = authState.profile
      ? { username: authState.profile.username, avatar_url: authState.profile.avatar_url }
      : null;

    if (session?.user) {
      formContainer?.classList.remove("hidden");
      loginPrompt?.classList.add("hidden");
    } else {
      formContainer?.classList.add("hidden");
      loginPrompt?.classList.remove("hidden");
    }

    // Sort dropdown handlers
    sortBtn?.addEventListener("click", (e) => {
      e.stopPropagation();
      sortDropdown?.classList.toggle("hidden");
    });

    document.addEventListener("click", () => {
      sortDropdown?.classList.add("hidden");
      emojiPicker?.classList.add("hidden");
    });

    sortDropdown?.querySelectorAll("button").forEach((btn) => {
      btn.addEventListener("click", async (e) => {
        e.stopPropagation();
        const sort = (e.target as HTMLElement).getAttribute("data-sort");
        if (sort) {
          currentSort = sort;
          if (sortLabel) {
            sortLabel.textContent =
              sort === "recent"
                ? "Most recent"
                : sort === "oldest"
                  ? "Oldest"
                  : "Most liked";
          }
          sortDropdown?.classList.add("hidden");
          await loadComments(true); // Skip cache when sorting
        }
      });
    });

    // Format button handlers
    document.querySelectorAll("[data-format]").forEach((btn) => {
      btn.addEventListener("click", () => {
        const format = btn.getAttribute("data-format");
        if (!commentInput || !format) return;

        const start = commentInput.selectionStart;
        const end = commentInput.selectionEnd;
        const text = commentInput.value;
        const selected = text.substring(start, end);

        let before = "",
          after = "";
        if (format === "bold") {
          before = "**";
          after = "**";
        } else if (format === "italic") {
          before = "*";
          after = "*";
        } else if (format === "underline") {
          before = "<u>";
          after = "</u>";
        }

        commentInput.value =
          text.substring(0, start) +
          before +
          selected +
          after +
          text.substring(end);
        commentInput.focus();
        commentInput.setSelectionRange(
          start + before.length,
          end + before.length
        );
      });
    });

    // Emoji picker handlers
    emojiBtn?.addEventListener("click", (e) => {
      e.stopPropagation();
      emojiPicker?.classList.toggle("hidden");
    });

    emojiPicker?.querySelectorAll(".emoji-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const emoji = (e.target as HTMLElement).textContent;
        if (commentInput && emoji) {
          const start = commentInput.selectionStart;
          const text = commentInput.value;
          commentInput.value =
            text.substring(0, start) + emoji + text.substring(start);
          commentInput.focus();
          commentInput.setSelectionRange(
            start + emoji.length,
            start + emoji.length
          );
        }
        emojiPicker?.classList.add("hidden");
      });
    });

    // Load comments
    await loadComments();

    async function loadComments(skipCache = false) {
      if (!commentsList) return;

      // Preserve scroll position
      const scrollY = window.scrollY;

      // Check cache first (only for default sort)
      if (!skipCache && currentSort === "recent") {
        const cached = getCachedComments(slug);
        if (cached) {
          // Use cached data
          if (commentCount) {
            commentCount.textContent = String(cached.count);
          }
          const sortedComments = cached.data as CommentWithProfile[];
          const threaded = buildThreadedComments(sortedComments);
          commentsList.innerHTML = renderComments(threaded, session?.user?.id);
          attachReplyHandlers(session?.user?.id);
          attachEditHandlers(session?.user?.id);
          attachDeleteHandlers(session?.user?.id);
          attachReactionHandlers(session?.user?.id);
          requestAnimationFrame(() => window.scrollTo(0, scrollY));
          return;
        }
      }

      let query = supabase
        .from("comments")
        .select(
          `
          *,
          profiles (id, username, avatar_url),
          comment_reactions (id, user_id, reaction_type)
        `
        )
        .eq("post_slug", slug);

      // Apply sorting
      if (currentSort === "recent") {
        query = query.order("created_at", { ascending: false });
      } else if (currentSort === "oldest") {
        query = query.order("created_at", { ascending: true });
      } else {
        query = query.order("created_at", { ascending: false });
      }

      const { data: comments, error } = await query;

      if (error) {
        console.error("Error loading comments:", error);
        commentsList.innerHTML =
          '<p class="text-red-500">Error loading comments</p>';
        return;
      }

      // Cache the results (for default sort)
      if (currentSort === "recent" && comments) {
        setCachedComments(slug, comments, comments.length);
      }

      // Update comment count
      if (commentCount) {
        commentCount.textContent = String(comments?.length || 0);
      }

      if (!comments || comments.length === 0) {
        commentsList.innerHTML =
          '<li class="text-zinc-500 text-sm list-none">No comments yet. Be the first to comment!</li>';
        return;
      }

      // Sort by popularity if needed (client-side for now)
      let sortedComments = comments as CommentWithProfile[];
      if (currentSort === "popular") {
        sortedComments = sortedComments.sort((a, b) => {
          const aLikes = (a.comment_reactions || []).filter(
            (r) => r.reaction_type === "like"
          ).length;
          const bLikes = (b.comment_reactions || []).filter(
            (r) => r.reaction_type === "like"
          ).length;
          return bLikes - aLikes;
        });
      }

      // Build threaded comments
      const threaded = buildThreadedComments(sortedComments);
      commentsList.innerHTML = renderComments(threaded, session?.user?.id);

      // Attach handlers
      attachReplyHandlers(session?.user?.id);
      attachEditHandlers(session?.user?.id);
      attachDeleteHandlers(session?.user?.id);
      attachReactionHandlers(session?.user?.id);

      // Restore scroll position
      requestAnimationFrame(() => {
        window.scrollTo(0, scrollY);
      });
    }

    function buildThreadedComments(
      comments: CommentWithProfile[]
    ): CommentWithProfile[] {
      const map = new Map<string, CommentWithProfile>();
      const roots: CommentWithProfile[] = [];

      comments.forEach((c) => {
        c.replies = [];
        map.set(c.id, c);
      });

      comments.forEach((c) => {
        if (c.parent_id && map.has(c.parent_id)) {
          map.get(c.parent_id)!.replies!.push(c);
        } else {
          roots.push(c);
        }
      });

      return roots;
    }

    function renderComments(
      comments: CommentWithProfile[],
      currentUserId?: string,
      depth = 0
    ): string {
      return comments
        .map((comment) => {
          const isOwner = currentUserId === comment.user_id;
          const timeAgo = getTimeAgo(new Date(comment.created_at));
          const hasReplies = comment.replies && comment.replies.length > 0;

          // Calculate reactions
          const reactions = comment.comment_reactions || [];
          const likes = reactions.filter(
            (r) => r.reaction_type === "like"
          ).length;
          const dislikes = reactions.filter(
            (r) => r.reaction_type === "dislike"
          ).length;
          const userReaction = currentUserId
            ? reactions.find((r) => r.user_id === currentUserId)?.reaction_type
            : null;

          return `
          <li class="comment-item ${hasReplies ? "has-replies" : ""}" data-comment-id="${comment.id}">
            <div class="comment-row">
              <div class="thread-line-cell"></div>
              <div class="comment-main">
                <img src="${comment.profiles?.avatar_url || "/default-avatar.png"}" alt="${comment.profiles?.username || "User"}" class="avatar rounded-full object-cover flex-shrink-0" />
                <div class="comment-body flex-1 min-w-0">
                  <div class="flex items-center gap-2 mb-1">
                    <span class="text-sm font-medium text-zinc-900 dark:text-zinc-100">${comment.profiles?.username || "Anonymous"}</span>
                    <span class="text-xs text-zinc-500 dark:text-zinc-400">${timeAgo}</span>
                  </div>
                  <div class="comment-text text-sm text-zinc-700 dark:text-zinc-200 mb-3 leading-relaxed" data-original-content="${escapeHtml(comment.content)}">${renderMarkdown(comment.content)}</div>
                  <div class="edit-form-container hidden mb-3"></div>
                  <div class="flex items-center gap-4 text-xs text-zinc-500 dark:text-zinc-400">
                    <button class="like-btn flex items-center gap-1 hover:text-zinc-700 dark:hover:text-zinc-300 ${userReaction === "like" ? "text-accent" : ""}" data-comment-id="${comment.id}" data-reaction="like" data-user-reaction="${userReaction || ""}">
                      <svg class="w-4 h-4" fill="${userReaction === "like" ? "currentColor" : "none"}" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg>
                      <span>${likes || ""}</span>
                    </button>
                    <button class="dislike-btn flex items-center gap-1 hover:text-zinc-700 dark:hover:text-zinc-300 ${userReaction === "dislike" ? "text-accent" : ""}" data-comment-id="${comment.id}" data-reaction="dislike" data-user-reaction="${userReaction || ""}">
                      <svg class="w-4 h-4" fill="${userReaction === "dislike" ? "currentColor" : "none"}" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14H5.236a2 2 0 01-1.789-2.894l3.5-7A2 2 0 018.736 3h4.018a2 2 0 01.485.06l3.76.94m-7 10v5a2 2 0 002 2h.096c.5 0 .905-.405.905-.904 0-.715.211-1.413.608-2.008L17 13V4m-7 10h2m5-10h2a2 2 0 012 2v6a2 2 0 01-2 2h-2.5"></path></svg>
                      <span>${dislikes || ""}</span>
                    </button>
                    ${currentUserId ? `<button class="reply-btn hover:text-zinc-700 dark:hover:text-zinc-300" data-parent-id="${comment.id}">Reply</button>` : ""}
                    ${isOwner ? `<button class="edit-btn hover:text-zinc-700 dark:hover:text-zinc-300" data-comment-id="${comment.id}">Edit</button>` : ""}
                    ${isOwner ? `<button class="delete-btn hover:text-red-500" data-comment-id="${comment.id}">Delete</button>` : ""}
                  </div>
                  <div class="reply-form-container hidden mt-3"></div>
                </div>
              </div>
            </div>
            ${hasReplies ? `<ul class="replies">${renderComments(comment.replies!, currentUserId, depth + 1)}</ul>` : ""}
          </li>
        `;
        })
        .join("");
    }

    function renderMarkdown(text: string): string {
      let html = escapeHtml(text);
      // Convert newlines to <br>
      html = html.replace(/\n/g, "<br>");
      // Bold: **text**
      html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
      // Italic: *text*
      html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
      // Underline: <u>text</u> (already escaped, so match the escaped version)
      html = html.replace(/&lt;u&gt;(.+?)&lt;\/u&gt;/g, "<u>$1</u>");
      return html;
    }

    function escapeHtml(text: string): string {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    function getTimeAgo(date: Date): string {
      const seconds = Math.floor(
        (new Date().getTime() - date.getTime()) / 1000
      );

      if (seconds < 60) return "just now";
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
      if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
      if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
      return date.toLocaleDateString();
    }

    function attachReactionHandlers(currentUserId?: string) {
      document.querySelectorAll(".like-btn, .dislike-btn").forEach((btn) => {
        btn.addEventListener("click", async (e) => {
          e.preventDefault();
          if (!currentUserId) {
            alert("Please sign in to react");
            return;
          }

          const target = e.currentTarget as HTMLElement;
          const commentId = target.getAttribute("data-comment-id");
          const reactionType = target.getAttribute("data-reaction") as
            | "like"
            | "dislike";
          const currentReaction = target.getAttribute("data-user-reaction");

          if (!commentId) return;

          // Find the comment element and both buttons
          const commentEl = target.closest(".comment-item");
          const likeBtn = commentEl?.querySelector('.like-btn[data-comment-id="' + commentId + '"]') as HTMLElement;
          const dislikeBtn = commentEl?.querySelector('.dislike-btn[data-comment-id="' + commentId + '"]') as HTMLElement;
          const likeCountSpan = likeBtn?.querySelector("span");
          const dislikeCountSpan = dislikeBtn?.querySelector("span");

          // Get current counts
          const currentLikes = parseInt(likeCountSpan?.textContent || "0") || 0;
          const currentDislikes = parseInt(dislikeCountSpan?.textContent || "0") || 0;

          // Optimistic update - update UI immediately
          if (currentReaction === reactionType) {
            // Removing reaction
            target.classList.remove("text-accent");
            target.setAttribute("data-user-reaction", "");
            target.querySelector("svg")?.setAttribute("fill", "none");
            if (reactionType === "like" && likeCountSpan) {
              likeCountSpan.textContent = currentLikes > 1 ? String(currentLikes - 1) : "";
            } else if (reactionType === "dislike" && dislikeCountSpan) {
              dislikeCountSpan.textContent = currentDislikes > 1 ? String(currentDislikes - 1) : "";
            }
          } else if (currentReaction) {
            // Switching reaction
            const otherBtn = reactionType === "like" ? dislikeBtn : likeBtn;
            const otherCountSpan = reactionType === "like" ? dislikeCountSpan : likeCountSpan;

            // Remove from other
            otherBtn?.classList.remove("text-accent");
            otherBtn?.querySelector("svg")?.setAttribute("fill", "none");
            if (otherCountSpan) {
              const otherCount = parseInt(otherCountSpan.textContent || "0") || 0;
              otherCountSpan.textContent = otherCount > 1 ? String(otherCount - 1) : "";
            }

            // Add to current
            target.classList.add("text-accent");
            target.setAttribute("data-user-reaction", reactionType);
            target.querySelector("svg")?.setAttribute("fill", "currentColor");
            if (reactionType === "like" && likeCountSpan) {
              likeCountSpan.textContent = String(currentLikes + 1);
            } else if (reactionType === "dislike" && dislikeCountSpan) {
              dislikeCountSpan.textContent = String(currentDislikes + 1);
            }

            // Update both buttons' data-user-reaction
            likeBtn?.setAttribute("data-user-reaction", reactionType === "like" ? "like" : "");
            dislikeBtn?.setAttribute("data-user-reaction", reactionType === "dislike" ? "dislike" : "");
          } else {
            // New reaction
            target.classList.add("text-accent");
            target.setAttribute("data-user-reaction", reactionType);
            target.querySelector("svg")?.setAttribute("fill", "currentColor");
            if (reactionType === "like" && likeCountSpan) {
              likeCountSpan.textContent = String(currentLikes + 1);
            } else if (reactionType === "dislike" && dislikeCountSpan) {
              dislikeCountSpan.textContent = String(currentDislikes + 1);
            }

            // Update both buttons' data-user-reaction
            likeBtn?.setAttribute("data-user-reaction", reactionType === "like" ? "like" : "");
            dislikeBtn?.setAttribute("data-user-reaction", reactionType === "dislike" ? "dislike" : "");
          }

          // Invalidate cache since we modified data
          invalidateComments(slug);

          // Send to server in background (no full reload)
          if (currentReaction === reactionType) {
            await supabase
              .from("comment_reactions")
              .delete()
              .eq("comment_id", commentId)
              .eq("user_id", currentUserId);
          } else if (currentReaction) {
            await supabase
              .from("comment_reactions")
              .update({ reaction_type: reactionType })
              .eq("comment_id", commentId)
              .eq("user_id", currentUserId);
          } else {
            await supabase.from("comment_reactions").insert({
              comment_id: commentId,
              user_id: currentUserId,
              reaction_type: reactionType,
            });
          }
          // No loadComments() - optimistic update already handled UI
        });
      });
    }

    function attachReplyHandlers(currentUserId?: string) {
      if (!currentUserId) return;

      document.querySelectorAll(".reply-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const target = e.target as HTMLElement;
          const parentId = target.getAttribute("data-parent-id");
          const commentEl = target.closest("[data-comment-id]");
          const container = commentEl?.querySelector(".reply-form-container");

          if (!container) return;

          // Toggle reply form
          if (container.classList.contains("hidden")) {
            // Hide all other reply forms
            document.querySelectorAll(".reply-form-container").forEach((c) => {
              c.classList.add("hidden");
              c.innerHTML = "";
            });

            container.classList.remove("hidden");
            container.innerHTML = `
              <form class="reply-form space-y-2">
                <textarea
                  name="content"
                  placeholder="Write a reply..."
                  rows="2"
                  class="w-full px-3 py-2 text-sm rounded-lg border border-zinc-300 dark:border-zinc-600 bg-white dark:bg-zinc-800 text-zinc-900 dark:text-zinc-100 placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-accent focus:border-transparent resize-none"
                ></textarea>
                <div class="flex justify-end gap-2">
                  <button type="button" class="cancel-reply text-sm text-zinc-500 hover:text-zinc-700 dark:hover:text-zinc-300">
                    Cancel
                  </button>
                  <button type="submit" class="px-3 py-1 text-sm bg-accent text-white rounded-lg hover:opacity-90 transition-opacity">
                    Reply
                  </button>
                </div>
              </form>
            `;

            // Attach form handlers
            const form = container.querySelector(".reply-form");
            const cancelBtn = container.querySelector(".cancel-reply");

            cancelBtn?.addEventListener("click", () => {
              container.classList.add("hidden");
              container.innerHTML = "";
            });

            form?.addEventListener("submit", async (e) => {
              e.preventDefault();
              const textarea = form.querySelector("textarea");
              const content = textarea?.value.trim();

              if (!content) return;

              const { error } = await supabase.from("comments").insert({
                post_slug: slug,
                user_id: currentUserId,
                parent_id: parentId,
                content,
              });

              if (error) {
                console.error("Error posting reply:", error);
                alert("Failed to post reply");
                return;
              }

              // Invalidate cache and reload
              invalidateComments(slug);
              await loadComments(true);
            });
          } else {
            container.classList.add("hidden");
            container.innerHTML = "";
          }
        });
      });
    }

    function attachEditHandlers(currentUserId?: string) {
      if (!currentUserId) return;

      document.querySelectorAll(".edit-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const target = e.currentTarget as HTMLElement;
          const commentId = target.getAttribute("data-comment-id");
          const commentEl = target.closest(".comment-item");
          const commentText = commentEl?.querySelector(".comment-text");
          const editContainer = commentEl?.querySelector(".edit-form-container");

          if (!commentText || !editContainer) return;

          // Get original content
          const originalContent = commentText.getAttribute("data-original-content") || "";

          // Toggle edit form
          if (editContainer.classList.contains("hidden")) {
            // Hide comment text, show edit form
            commentText.classList.add("hidden");
            editContainer.classList.remove("hidden");
            editContainer.innerHTML = `
              <form class="edit-form space-y-2">
                <textarea
                  name="content"
                  rows="3"
                  class="w-full px-3 py-2 text-sm rounded-lg border border-zinc-300 dark:border-zinc-600 bg-white dark:bg-zinc-800 text-zinc-900 dark:text-zinc-100 placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-accent focus:border-transparent resize-none"
                >${originalContent}</textarea>
                <div class="flex justify-end gap-2">
                  <button type="button" class="cancel-edit text-sm text-zinc-500 hover:text-zinc-700 dark:hover:text-zinc-300">
                    Cancel
                  </button>
                  <button type="submit" class="px-3 py-1 text-sm bg-accent text-white rounded-lg hover:opacity-90 transition-opacity">
                    Save
                  </button>
                </div>
              </form>
            `;

            // Focus textarea
            const textarea = editContainer.querySelector("textarea");
            textarea?.focus();
            textarea?.setSelectionRange(textarea.value.length, textarea.value.length);

            // Cmd/Ctrl + Enter to save
            textarea?.addEventListener("keydown", async (e) => {
              if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
                e.preventDefault();
                const form = editContainer.querySelector(".edit-form");
                form?.dispatchEvent(new Event("submit"));
              }
            });

            // Cancel button
            const cancelBtn = editContainer.querySelector(".cancel-edit");
            cancelBtn?.addEventListener("click", () => {
              commentText.classList.remove("hidden");
              editContainer.classList.add("hidden");
              editContainer.innerHTML = "";
            });

            // Submit form
            const form = editContainer.querySelector(".edit-form");
            form?.addEventListener("submit", async (e) => {
              e.preventDefault();
              const newContent = textarea?.value.trim();

              if (!newContent) return;

              // Optimistic update - update DOM immediately
              const previousContent = originalContent;
              (commentText as HTMLElement).innerHTML = renderMarkdown(newContent);
              (commentText as HTMLElement).setAttribute("data-original-content", escapeHtml(newContent));
              commentText.classList.remove("hidden");
              editContainer.classList.add("hidden");
              editContainer.innerHTML = "";

              // Invalidate cache
              invalidateComments(slug);

              // Send to server in background
              const { error } = await supabase
                .from("comments")
                .update({ content: newContent, updated_at: new Date().toISOString() })
                .eq("id", commentId)
                .eq("user_id", currentUserId);

              if (error) {
                // Revert on error
                console.error("Error updating comment:", error);
                (commentText as HTMLElement).innerHTML = renderMarkdown(previousContent);
                (commentText as HTMLElement).setAttribute("data-original-content", escapeHtml(previousContent));
                alert("Failed to update comment");
              }
            });
          } else {
            // Hide edit form, show comment text
            commentText.classList.remove("hidden");
            editContainer.classList.add("hidden");
            editContainer.innerHTML = "";
          }
        });
      });
    }

    function attachDeleteHandlers(currentUserId?: string) {
      if (!currentUserId) return;

      document.querySelectorAll(".delete-btn").forEach((btn) => {
        btn.addEventListener("click", async (e) => {
          const target = e.currentTarget as HTMLElement;
          const commentId = target.getAttribute("data-comment-id");
          const commentEl = target.closest(".comment-item");

          if (!confirm("Delete this comment?")) return;

          // Optimistic delete - remove from DOM immediately
          const removedHtml = commentEl?.outerHTML;
          commentEl?.remove();

          // Update comment count
          const currentCount = parseInt(commentCount?.textContent || "0");
          if (commentCount && currentCount > 0) {
            commentCount.textContent = String(currentCount - 1);
          }

          // Invalidate cache
          invalidateComments(slug);

          const { error } = await supabase
            .from("comments")
            .delete()
            .eq("id", commentId)
            .eq("user_id", currentUserId);

          if (error) {
            console.error("Error deleting comment:", error);
            alert("Failed to delete comment. Refreshing...");
            // Reload on error to restore state
            await loadComments(true);
          }
        });
      });
    }

    // Handle new comment submission
    async function submitComment() {
      const content = commentInput?.value.trim();
      if (!content || !session?.user || !commentsList) return;

      // Generate temporary ID for optimistic update
      const tempId = `temp-${Date.now()}`;

      // Build optimistic comment HTML
      const optimisticHtml = `
        <li class="comment-item" data-comment-id="${tempId}">
          <div class="comment-row">
            <div class="thread-line-cell"></div>
            <div class="comment-main">
              <img src="${currentUserProfile?.avatar_url || "/default-avatar.png"}" alt="${currentUserProfile?.username || "User"}" class="avatar rounded-full object-cover flex-shrink-0" />
              <div class="comment-body flex-1 min-w-0">
                <div class="flex items-center gap-2 mb-1">
                  <span class="text-sm font-medium text-zinc-900 dark:text-zinc-100">${currentUserProfile?.username || "Anonymous"}</span>
                  <span class="text-xs text-zinc-500 dark:text-zinc-400">just now</span>
                </div>
                <div class="comment-text text-sm text-zinc-700 dark:text-zinc-200 mb-3 leading-relaxed" data-original-content="${escapeHtml(content)}">${renderMarkdown(content)}</div>
                <div class="edit-form-container hidden mb-3"></div>
                <div class="flex items-center gap-4 text-xs text-zinc-500 dark:text-zinc-400">
                  <button class="like-btn flex items-center gap-1 hover:text-zinc-700 dark:hover:text-zinc-300" data-comment-id="${tempId}" data-reaction="like" data-user-reaction="">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"></path></svg>
                    <span></span>
                  </button>
                  <button class="dislike-btn flex items-center gap-1 hover:text-zinc-700 dark:hover:text-zinc-300" data-comment-id="${tempId}" data-reaction="dislike" data-user-reaction="">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14H5.236a2 2 0 01-1.789-2.894l3.5-7A2 2 0 018.736 3h4.018a2 2 0 01.485.06l3.76.94m-7 10v5a2 2 0 002 2h.096c.5 0 .905-.405.905-.904 0-.715.211-1.413.608-2.008L17 13V4m-7 10h2m5-10h2a2 2 0 012 2v6a2 2 0 01-2 2h-2.5"></path></svg>
                    <span></span>
                  </button>
                  <button class="reply-btn hover:text-zinc-700 dark:hover:text-zinc-300" data-parent-id="${tempId}">Reply</button>
                  <button class="edit-btn hover:text-zinc-700 dark:hover:text-zinc-300" data-comment-id="${tempId}">Edit</button>
                  <button class="delete-btn hover:text-red-500" data-comment-id="${tempId}">Delete</button>
                </div>
                <div class="reply-form-container hidden mt-3"></div>
              </div>
            </div>
          </div>
        </li>
      `;

      // Optimistic update - add to DOM immediately
      const firstComment = commentsList.querySelector(".comment-item");
      if (firstComment) {
        firstComment.insertAdjacentHTML("beforebegin", optimisticHtml);
      } else {
        // No comments yet, replace the "no comments" message
        commentsList.innerHTML = optimisticHtml;
      }

      // Update comment count
      const currentCount = parseInt(commentCount?.textContent || "0");
      if (commentCount) commentCount.textContent = String(currentCount + 1);

      // Clear input
      if (commentInput) commentInput.value = "";

      // Send to server in background
      const { data, error } = await supabase
        .from("comments")
        .insert({
          post_slug: slug,
          user_id: session.user.id,
          content,
        })
        .select()
        .single();

      if (error) {
        // Remove optimistic comment on error
        console.error("Error posting comment:", error);
        const tempComment = commentsList.querySelector(`[data-comment-id="${tempId}"]`);
        tempComment?.remove();
        if (commentCount) commentCount.textContent = String(currentCount);
        alert("Failed to post comment");
        return;
      }

      // Invalidate cache since we added new comment
      invalidateComments(slug);

      // Update the temp ID with the real ID
      const tempComment = commentsList.querySelector(`[data-comment-id="${tempId}"]`);
      if (tempComment && data) {
        tempComment.setAttribute("data-comment-id", data.id);
        // Update all buttons with the real ID
        tempComment.querySelectorAll(`[data-comment-id="${tempId}"]`).forEach(el => {
          el.setAttribute("data-comment-id", data.id);
        });
        tempComment.querySelectorAll(`[data-parent-id="${tempId}"]`).forEach(el => {
          el.setAttribute("data-parent-id", data.id);
        });
        // Attach handlers to the new comment
        attachEditHandlers(session.user.id);
        attachDeleteHandlers(session.user.id);
        attachReactionHandlers(session.user.id);
        attachReplyHandlers(session.user.id);
      }
    }

    commentForm?.addEventListener("submit", async (e) => {
      e.preventDefault();
      await submitComment();
    });

    // Cmd/Ctrl + Enter to submit comment
    commentInput?.addEventListener("keydown", async (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
        e.preventDefault();
        e.stopPropagation();
        await submitComment();
      }
    });
  }

  // Initial load
  initCommentSection();

  // Handle Astro view transitions
  document.addEventListener("astro:after-swap", initCommentSection);
</script>

<style is:global>
  /* === Comment Thread Base Variables === */
  .comment-thread {
    --avatar-size: 2rem;
    --line-color: #d4d4d8;
    --line-width: 2px;
    --line-radius: 8px;
    --indent: calc(var(--avatar-size) + 0.75rem); /* avatar + gap */
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .dark .comment-thread {
    --line-color: #52525b;
  }

  /* === Comment Item (li) === */
  .comment-item {
    list-style: none;
    margin-top: 1rem;
    position: relative;
  }

  .comment-thread > .comment-item:first-child {
    margin-top: 0;
  }

  /* === Comment Row - simple flex, no grid === */
  .comment-row {
    display: flex;
    gap: 0.75rem;
  }

  /* Hide the thread-line-cell - we don't need it anymore */
  .thread-line-cell {
    display: none;
  }

  /* === Comment Main (avatar + body) === */
  .comment-main {
    display: flex;
    gap: 0.75rem;
    flex: 1;
  }

  .comment-main .avatar {
    width: var(--avatar-size);
    height: var(--avatar-size);
    flex-shrink: 0;
    position: relative;
    z-index: 1;
  }

  /* === Nested Replies === */
  .replies {
    list-style: none;
    padding: 0;
    margin: 0;
    margin-left: calc(var(--avatar-size) / 2); /* Align with center of parent avatar */
    padding-left: calc(var(--avatar-size) / 2 + 0.75rem); /* Rest of avatar + gap */
  }

  /* === Thread Lines === */

  /* 1. Vertical line from parent with replies - positioned on the comment-item */
  .comment-item.has-replies::after {
    content: "";
    position: absolute;
    left: calc(var(--avatar-size) / 2 - var(--line-width) / 2);
    top: var(--avatar-size);
    bottom: 0;
    width: var(--line-width);
    background: var(--line-color);
  }

  /* 2. L-connector for each reply */
  .replies > .comment-item::before {
    content: "";
    position: absolute;
    left: calc(-1 * (var(--avatar-size) / 2 + 0.75rem)); /* Back to parent's vertical line */
    top: calc(-1rem);
    width: calc(var(--avatar-size) / 2 + 0.75rem + var(--avatar-size) / 2);
    height: calc(var(--avatar-size) / 2 + 1rem);
    border-left: var(--line-width) solid var(--line-color);
    border-bottom: var(--line-width) solid var(--line-color);
    border-bottom-left-radius: var(--line-radius);
    border-right: none;
    border-top: none;
  }

  /* === Toggle Lines Off === */
  .comment-thread[style*="--lines: false"] .comment-item::before,
  .comment-thread[style*="--lines: false"] .comment-item::after {
    display: none;
  }
</style>
