---
import AuthButton from '../auth/AuthButton.astro';

interface Props {
  slug: string;
}

const { slug } = Astro.props;
---

<section class="comment-section mt-16 pt-8 border-t border-zinc-200 dark:border-zinc-800" data-slug={slug}>
  <h2 class="text-2xl font-bold mb-6 text-zinc-900 dark:text-zinc-100">Comments</h2>

  <!-- Auth -->
  <div class="mb-8">
    <AuthButton />
  </div>

  <!-- Comment Form (shown when logged in) -->
  <div id="comment-form-container" class="hidden mb-8">
    <form id="comment-form" class="space-y-4">
      <textarea
        id="comment-input"
        name="content"
        placeholder="Write a comment..."
        rows="3"
        class="w-full px-4 py-3 rounded-lg border border-zinc-300 dark:border-zinc-600 bg-white dark:bg-zinc-800 text-zinc-900 dark:text-zinc-100 placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-accent focus:border-transparent resize-none"
      ></textarea>
      <div class="flex justify-end">
        <button
          type="submit"
          class="px-4 py-2 bg-accent text-white rounded-lg hover:opacity-90 transition-opacity disabled:opacity-50"
        >
          Post Comment
        </button>
      </div>
    </form>
  </div>

  <!-- Login prompt (shown when logged out) -->
  <div id="login-prompt" class="hidden mb-8 p-4 bg-zinc-100 dark:bg-zinc-800 rounded-lg text-center">
    <p class="text-zinc-600 dark:text-zinc-400">Sign in to leave a comment</p>
  </div>

  <!-- Comments List -->
  <div id="comments-list">
    <p class="text-zinc-500 text-sm">Loading comments...</p>
  </div>
</section>

<script>
  import { supabase, type Comment, type Profile } from '../../lib/supabase';

  interface CommentWithProfile extends Comment {
    profiles: Profile;
    replies?: CommentWithProfile[];
  }

  async function initCommentSection() {
    const section = document.querySelector('.comment-section');
    if (!section) return;

    const slug = section.getAttribute('data-slug');
    if (!slug) return;

    const formContainer = document.getElementById('comment-form-container');
    const loginPrompt = document.getElementById('login-prompt');
    const commentsList = document.getElementById('comments-list');
    const commentForm = document.getElementById('comment-form');
    const commentInput = document.getElementById('comment-input') as HTMLTextAreaElement;

    // Check auth state
    const { data: { session } } = await supabase.auth.getSession();

    if (session?.user) {
      formContainer?.classList.remove('hidden');
      loginPrompt?.classList.add('hidden');
    } else {
      formContainer?.classList.add('hidden');
      loginPrompt?.classList.remove('hidden');
    }

    // Load comments
    await loadComments();

    async function loadComments() {
      if (!commentsList) return;

      const { data: comments, error } = await supabase
        .from('comments')
        .select(`
          *,
          profiles (id, username, avatar_url)
        `)
        .eq('post_slug', slug)
        .order('created_at', { ascending: true });

      if (error) {
        console.error('Error loading comments:', error);
        commentsList.innerHTML = '<p class="text-red-500">Error loading comments</p>';
        return;
      }

      if (!comments || comments.length === 0) {
        commentsList.innerHTML = '<p class="text-zinc-500 text-sm">No comments yet. Be the first to comment!</p>';
        return;
      }

      // Build threaded comments
      const threaded = buildThreadedComments(comments as CommentWithProfile[]);
      commentsList.innerHTML = renderComments(threaded, session?.user?.id);

      // Attach reply handlers
      attachReplyHandlers(session?.user?.id);
      attachDeleteHandlers(session?.user?.id);
    }

    function buildThreadedComments(comments: CommentWithProfile[]): CommentWithProfile[] {
      const map = new Map<string, CommentWithProfile>();
      const roots: CommentWithProfile[] = [];

      comments.forEach(c => {
        c.replies = [];
        map.set(c.id, c);
      });

      comments.forEach(c => {
        if (c.parent_id && map.has(c.parent_id)) {
          map.get(c.parent_id)!.replies!.push(c);
        } else {
          roots.push(c);
        }
      });

      return roots;
    }

    function renderComments(comments: CommentWithProfile[], currentUserId?: string, isReply = false): string {
      return comments.map((comment) => {
        const isOwner = currentUserId === comment.user_id;
        const timeAgo = getTimeAgo(new Date(comment.created_at));
        const hasReplies = comment.replies && comment.replies.length > 0;

        return `
          <div class="${isReply ? 'ml-12' : ''}" style="margin-top: 1.25rem;" data-comment-id="${comment.id}">
            <div class="flex gap-3">
              <div class="flex-shrink-0">
                <img src="${comment.profiles?.avatar_url || '/default-avatar.png'}" alt="${comment.profiles?.username || 'User'}" class="w-8 h-8 rounded-full object-cover" />
              </div>
              <div class="flex-1 min-w-0">
                <div class="flex items-center gap-2 mb-1">
                  <span class="text-sm font-medium text-zinc-900 dark:text-zinc-100">${comment.profiles?.username || 'Anonymous'}</span>
                  <span class="text-xs text-zinc-500 dark:text-zinc-400">${timeAgo}</span>
                </div>
                <p class="text-sm text-zinc-700 dark:text-zinc-200 mb-3 leading-relaxed">${escapeHtml(comment.content)}</p>
                <div class="flex items-center gap-4 text-xs text-zinc-500 dark:text-zinc-400">${currentUserId ? `<button class="reply-btn hover:text-zinc-700 dark:hover:text-zinc-300" data-parent-id="${comment.id}">Reply</button>` : ''}${isOwner ? `<button class="delete-btn hover:text-red-500" data-comment-id="${comment.id}">Delete</button>` : ''}</div>
                <div class="reply-form-container hidden mt-3"></div>
              </div>
            </div>
            ${hasReplies ? `<div class="mt-5">${renderComments(comment.replies!, currentUserId, true)}</div>` : ''}
          </div>
        `;
      }).join('');
    }

    function escapeHtml(text: string): string {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function getTimeAgo(date: Date): string {
      const seconds = Math.floor((new Date().getTime() - date.getTime()) / 1000);

      if (seconds < 60) return 'just now';
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
      if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
      if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
      return date.toLocaleDateString();
    }

    function attachReplyHandlers(currentUserId?: string) {
      if (!currentUserId) return;

      document.querySelectorAll('.reply-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const target = e.target as HTMLElement;
          const parentId = target.getAttribute('data-parent-id');
          const commentEl = target.closest('[data-comment-id]');
          const container = commentEl?.querySelector('.reply-form-container');

          if (!container) return;

          // Toggle reply form
          if (container.classList.contains('hidden')) {
            // Hide all other reply forms
            document.querySelectorAll('.reply-form-container').forEach(c => {
              c.classList.add('hidden');
              c.innerHTML = '';
            });

            container.classList.remove('hidden');
            container.innerHTML = `
              <form class="reply-form space-y-2">
                <textarea
                  name="content"
                  placeholder="Write a reply..."
                  rows="2"
                  class="w-full px-3 py-2 text-sm rounded-lg border border-zinc-300 dark:border-zinc-600 bg-white dark:bg-zinc-800 text-zinc-900 dark:text-zinc-100 placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-accent focus:border-transparent resize-none"
                ></textarea>
                <div class="flex justify-end gap-2">
                  <button type="button" class="cancel-reply text-sm text-zinc-500 hover:text-zinc-700 dark:hover:text-zinc-300">
                    Cancel
                  </button>
                  <button type="submit" class="px-3 py-1 text-sm bg-accent text-white rounded-lg hover:opacity-90 transition-opacity">
                    Reply
                  </button>
                </div>
              </form>
            `;

            // Attach form handlers
            const form = container.querySelector('.reply-form');
            const cancelBtn = container.querySelector('.cancel-reply');

            cancelBtn?.addEventListener('click', () => {
              container.classList.add('hidden');
              container.innerHTML = '';
            });

            form?.addEventListener('submit', async (e) => {
              e.preventDefault();
              const textarea = form.querySelector('textarea');
              const content = textarea?.value.trim();

              if (!content) return;

              const { error } = await supabase
                .from('comments')
                .insert({
                  post_slug: slug,
                  user_id: currentUserId,
                  parent_id: parentId,
                  content,
                });

              if (error) {
                console.error('Error posting reply:', error);
                alert('Failed to post reply');
                return;
              }

              await loadComments();
            });
          } else {
            container.classList.add('hidden');
            container.innerHTML = '';
          }
        });
      });
    }

    function attachDeleteHandlers(currentUserId?: string) {
      if (!currentUserId) return;

      document.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const target = e.target as HTMLElement;
          const commentId = target.getAttribute('data-comment-id');

          if (!confirm('Delete this comment?')) return;

          const { error } = await supabase
            .from('comments')
            .delete()
            .eq('id', commentId)
            .eq('user_id', currentUserId);

          if (error) {
            console.error('Error deleting comment:', error);
            alert('Failed to delete comment');
            return;
          }

          await loadComments();
        });
      });
    }

    // Handle new comment submission
    commentForm?.addEventListener('submit', async (e) => {
      e.preventDefault();

      const content = commentInput?.value.trim();
      if (!content || !session?.user) return;

      const { error } = await supabase
        .from('comments')
        .insert({
          post_slug: slug,
          user_id: session.user.id,
          content,
        });

      if (error) {
        console.error('Error posting comment:', error);
        alert('Failed to post comment');
        return;
      }

      if (commentInput) commentInput.value = '';
      await loadComments();
    });
  }

  // Initial load
  initCommentSection();

  // Handle Astro view transitions
  document.addEventListener('astro:after-swap', initCommentSection);
</script>

<style is:global>
  #comments-list > [data-comment-id]:first-child {
    margin-top: 0 !important;
  }
</style>
