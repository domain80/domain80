---
title: "Can You Master Something You Never Struggled With?"
description: "A reflection on how AI is changing the craft of software development, and whether we're trading away the struggle that makes us skilled."
pubDate: 2026-01-11
category: "Opinion"
tags: ["AI", "software-development", "career", "craftsmanship"]
featured: true
---

Back in the day, my goal was simple: build good software. Get the algorithms right. Structure data carefully. Debug until things made sense. Push to GitHub Pages, deploy with Vercel or Netlify, and move on. There was satisfaction in that workflow because the craft itself mattered.

Today, that mindset barely qualifies as baseline. AI is everywhere. Anyone can prompt their way to something that looks polished, ships quickly, and checks the right boxes. The conversation has shifted toward speed, toward “just building,” toward avoiding over-engineering. Somewhere in that shift, rigor stopped being part of the discussion. Basic competence, once the standard, is no longer celebrated.

## When Rare Things Become Common

There is a simple economic truth here: scarcity creates value. When coding was hard, when debugging demanded patience and understanding data structures took real effort, those skills mattered. Mastery had weight because it was earned slowly.

AI compresses that journey. What once took months now takes minutes. When the rare thing becomes common, the question is not whether output increases. It does. The question is what becomes valuable instead.

The usual reassurance is that AI will only replace those who do not know how to use it. That framing hides a quieter cost. Using AI often means doing less of the work that builds intuition. Less manual debugging. Less depth in code reviews. Less time wrestling with failures. Over time, that understanding erodes. You still ship, but you own less of what you ship.

## Convenience and Skill Atrophy

I use AI tools. They are useful and often impressive. This is not a rejection of progress. It is a concern about what convenience quietly replaces.

A beginner today might learn how to prompt before learning how to debug. They might review AI-generated code before ever writing it from scratch. They might optimize prompts instead of algorithms.

That changes the learning curve. Building a hash table by hand teaches trade-offs. Refactoring a messy codebase builds judgment. Spending hours tracking down a segmentation fault develops instincts that no explanation can substitute. These skills come from friction.

When struggle is optional, learning becomes optional too.

The junior developer who lets Copilot fix a memory leak without understanding pointers has not learned memory management. They have learned how to ask for a fix. Those are not the same thing.

The “just build” mindset assumes shipping is the only metric that matters. But much of engineering skill is developed during the slow and uncomfortable parts of building, when things break and the cause is not yet clear.

## The Paradox

There is something strange about how eagerly developers celebrate tools that reduce the need for developers. Each major model release brings another wave of posts declaring that software engineering is dead. These are often shared enthusiastically by engineers themselves.

The assumption is always personal immunity. It is other people who will be replaced. But if AI reduces the need for deep understanding, and fewer people develop that understanding, the profession changes in ways that are hard to reverse.

If fewer engineers can evaluate correctness, performance, or long-term maintainability, the ceiling for quality drops, even if output increases.

## My Practical Way Forward

I believe change is not optional, and nostalgia is not a strategy. The answer may not be to reject AI, but to be deliberate about how it is used.

Again I believe the baseline still matters. Fundamentals still matter. The goal should be to use AI to amplify understanding, not replace it. That means knowing what code you would have written before asking AI to do so or improve it, understanding failures you ask AI to handle, treating AI output as a draft rather than an answer, and ensuring learning still happens where convenience encourages skipping it.

Mastery has always adapted. We moved from assembly to compilers, from manual DOM manipulation to frameworks, from raw SQL to ORMs. Each shift raised the level of abstraction while still requiring understanding beneath it.

Maybe this time is no different. Or maybe it is.

What feels new is how thoroughly struggle can be removed from the process. We are about to learn whether skill can develop without friction, or whether AI-assisted development quietly creates a ceiling that only becomes visible once we hit it.
